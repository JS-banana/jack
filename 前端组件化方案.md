# 前端组件化方案

## 基本目标

1. 友好的项目设计、较低的上手门槛
2. 易于维护和调试的独立方案
3. 规范化的项目工程化管理
4. 详细和功能完备的文档网站
5. 优雅的包管理方案
6. 测试

## 目标拆解

### 1. 友好的项目设计、较低的上手门槛

常规套路，我们接手一个新的仓库代码，首先，要了解仓库的相关依赖、目录结构、规范、开发逻辑等，之后的开发人员便按照此逻辑进行开发和迭代。

好的设计能够让我们快速的介入进来，无感的进行核心功能的开发，不受其项目影响。而相对的，不清晰的目录划分和无规则的逻辑会极大的增加我们的上手成本，包括日后的可维护性都会大打折扣。

因此，该设计应该能显著减少我们的上手成本，并降低我们对这些代码之外的关注点的投入。

1. 新人可以快速上手，学习门槛较低。通过简单的介绍就能够理解本项目的开发范式，并可快速投入开发。
2. 有着合理、清晰的文件目录划分，整个项目有着清晰的结构。目录的设计和功能息息相关，便于维护，并能够围绕目录结构设计做到一些功能的脚本自动化处理。

### 2. 易于维护和调试的独立方案

如何理解维护？我觉得抛开项目创建者，参与进来的其他开发人员或多或少都和维护角色有点关系。特别针对后期加入进来的开发人员而言，对于某一功能的迭代、优化、开发新特性等。

如何做到快速参与进来，接手和维护之前的功能代码呢?这一点至关重要。

1. 清晰的注释。包括但不限于一些API的说明，方法、属性的介绍。
2. 合理的拆分和目录划分。功能代码、逻辑代码、业务代码、工具代码应该有比较清晰的划分。如：相关常量定义、json配置相关代码。
3. 各组件应相对独立。在项目中的目录相对独立、在开发调试能够一定程度的相对独立、单一组件可以独立开发维护，以及在最终使用引入时。
4. 对于是否支持TypeScript，结合实际情况目前暂定

### 3. 规范化的项目工程化管理

首先，在能够强制保证的条件下采用eslint等规范做到主要规范控制，配合vscode等工具链做到工程化方面的约束。

其次，在不能具体由工程化方面控制的地方，做到统一约束，包括目录结构的设计等，并输出规范文档，确保足够清晰简单，方便新人执行。

1. eslint + prettier + commitlint （editorconfig）。在工程化方面保证相关规范强制执行。
2. 结合目录划分结构，按照设计规划规范执行相关准则，做到统一约束。如monorepo多包管理方案，及开源社区的最佳实践等（element-plus、tdesign-vue、ant-design-vue等）。
3. 并基于第2点此约束条件，产出部分自动化脚本工具，包括但不限于路由生成、源码展示、demo演示、npm发布处理等。

### 4. 详细和功能完备的文档网站

文档网站——其功能性和重要性不言而喻，主要作为第一入口提供给用户，作为了解本项目的第一途径。

1. 第一要素：使用指南，组件API、属性、方法等相关介绍说明，
2. 第二点：使用方式和用法展示。真实渲染环境展示效果，相关代码使用展示（demo / code）。

### 5. 优雅的包管理方案

1. 最大限度的精简每个组件的引入加载代码。如：按需加载时，只加载自身相关代码。
2. 使用monorepo多包管理方案，更好的管理不同组件、工具、库的代码，统一管理npm发包。
3. 按组件能力划分基础UI组件和高级组件。基础组件采用iview等UI库的方案，整体维护，支持按需加载。高级组件独立维护，采用单独发包的方案，最大程度的做到独立，更好的维护。

## 方案梳理

1. 命名规范
   - 组件目录小写命名：为了符合package.json包名的命名规则，以及在项目中保持目录名称统一，组件目录以小写字母为标准，不支持大写字母。（`pro-sqltiptree`）
   - 组件导入导出首字母大写：作为组件，按照标准化方案，导出时和引入时，应该按照首字母大写的形式，并以驼峰式写法。（`ProSqlTipTree`）
   - 工具类的相关函数名称：应该以小写字母开头，按照驼峰式名称规范，并保证具有一定的语义化。（`getSortListById`）
   - 常量类：全大写，并以下划线拼接。（`BUTTON_TYPE`）

2. 采用monorepo方案，更好的版本管理，相关源码统一在 packages/* 下面维护，可以实现每个文件目录作为一个npm包发布使用。

    ```js
    ├── packages                           // packages工作目录
        ├── utils                          // 工具库
        ├── pro-sqltiptree                 // 高级组件之一，独单作为一个npm包
        ├── components                     // 基础组件，整体作为一个npm包，内部组件按需加载使用
            ├── select                     // 基础组件之一 Select，
            ├── ...       
    ```

    ```js
    // 用法示例
    import { Select } from '@ah-ailpha/components'
    import ProSqlTipTree from '@ah-ailpha/pro-sqltiptree'
    ```

3. 目录划分设计，唯一出入口，职责分明。源码文件、demo文件、文档

    ```js
    ├── packages                       // packages工作目录
        ├── components                 // 组件目录
        ├── examples                   // 演示网站，应包含所有组件、文档、源码信息。自动关联到每个组件目录，并生成代码
    ```

    ```js
    // 基础组件示例
    ├── select                         // Select组件的开发目录
        // ├── __tests__               // 测试相关
        ├── style                      // 组件相关样式代码
        ├── demo                       // demo演示源码目录，这里会配合开发工具和脚本实现渲染展示
        ├── docs                       // docs文档说明
        ├── src                        // 组件源码目录
            ├── select.vue             // 组件源码
            ├── props.js               // props相关定义的声明
            ├── const.js               // 常量
        ├── index.js                   // 统一出入口
    ```

    ```js
    // 高级组件示例
    ├── packages                           // packages工作目录
        ├── pro-sqltiptree                 // 高级组件之一，独单作为一个npm包
            // ├── __tests__               // 测试相关
            ├── examples                   // 演示网站
            ├── style                      // 组件相关样式代码
            ├── demo                       // demo演示源码目录，这里会配合开发工具和脚本实现渲染展示
            ├── docs                       // docs文档说明
            ├── src                        // 组件源码目录
                ├── select.vue             // 组件源码
                ├── props.js               // props相关定义的声明
                ├── const.js               // 常量
            ├── index.js                   // 统一出入口
            ├── package.json               // package.json 文件
    ```

4. 开发调试和编译打包

    - 基于背景因素，打包还是走Webpack方案，求稳，兼容老旧的方案
    - 开发调试为了寻求体验统一目前也与Webpack保持一致
    - 文档网站可以考虑使用vite生态链工具，高性能快速实现，向下兼容方案采用Webpack
