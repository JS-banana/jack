# 前端组件化探究

## 前端的发展路径

在互联网早期阶段，传统的开发模式中，往往是把前端的网页代码和后端的程序代码混合在一起，借助某种模板技术（如 JSP、ASP、PHP）来在服务器端动态生成 HTML 页面。

在这种开发模式下，网页的每次改动都需要前后端人员共同参与才能完成，网站前后端的开发人员需要很大的沟通成本、协调成本。企业招人的时候，也不得不招一些既懂前端又懂后端程序员，来减少前后端开发人员的冲突。

可以发现这种模式是非常低效的。

现在流行的前后端分离的开发模式，就是让后端只负责给前端提供数据，由前端负责整个页面的模板渲染、数据填充以及交互逻辑。

前后端分离之后，人们发现前端已经不再是传统意义上的网页了，它甚至还可以做成一个手机应用，或者做成是微信小程序那样的小型应用，**它更接近于传统的 B/S（客户端/服务器）架构，且仍然具备网页轻量级、无需下载和安装的优势**。

## 为什么需要组件化

组件化的目的：

1. 为了让页面中的各个部分可以被复用，以减少重复的代码。

2. 另一方面，也可以更好地使团队分工协作，让不同的人负责编写不同的组件。

对于需要开发复杂的大型应用的企业来说，组件化开发能极大地提高开发效率，它让前端开发团队能高效地完成工作，是一个非常有用的技术。

## 什么是组件化

在前后端分离的现代开发模式下，以`React`、`Vue`为例，涌现了很多优秀的现代化的前端框架，得益于新技术的发展，SPA 应用已经相当成熟，该开发范式也是相当普遍，各个互联网公司基本都迈入了。

伴随着这种技术行为，组件化开发也是应运而生，作为一个非常常规的模式，围绕几点说明：

1. 方便复用（很多业务代码、功能代码都不可避免有所重复，对于组件的复用使用，可谓作用很大）
2. 方便维护（如果大量的业务代码与功能代码耦合一起，对于代码的日后维护和功能拓展都有着很大的局限性和不足）
3. 功能细分、专一、职责明确（组件的核心原则就是，一个组件只做一件事，而且其不应该是有上下强关联耦合性的，可以随用随取，做到职责单一，对于日后功能迭代和代码维护好处都是显而易见的）

## 基本目标

> 核心述求：
>
> 1. 不同的业务平台开发的组件能够最大程度复用；
>
> 2. 新人能够快速了解通用组件，提升开发效率

1. 提供一个方便不同业务平台组件复用的方案
   - 主要围绕业务组件、二次封装的功能组件进行管理
   - 使用时类似 npm 包一样，直接进行安装使用
   - 组件迭代维护要足够方便
2. 文档网站平台搭建
   - 组件的基本 api、参数类型、示例、作用，使用文档等要有描述
   - 真实组件的渲染，可交互，最好能直接复制代码
   - 可访问查看的一个文档网站
3. 以 npm 包的形式+文档为最终效果
   - 对于多个不同的业务组件，由清晰的文档可查
   - 直接安装使用

## 技术背景

以公司实际项目为背景思考，主要围绕 vue2 相关技术栈进行前端 web 后台类系统的开发。

### 包依赖

- 核心三大件：`vue`/`vue-router`/`vuex`
- UI 类：`view-design`、`codemirror`、`monaco-editor`、`vue-echarts`、`vuedraggble`
- 工具类：`lodash`、`dayjs`、`uuid`

围绕以上技术相关生态，做到对各部分及功能使用的二次封装管理

主要 API 及实际项目代码分析：

- **slot**：组件拆分、UI 布局、自定义展示区域的好方法
- **props**：父组件向子组件传递参数
- **ref**：父组件获取子组件方法、属性
- **emit**：子组件向父组件传递参数，触发父组件绑定事件方法
- **provide/inject**：多级子父组件传值
- **vuex**：第三方状态管理（需要考虑单一组件的可维护性）

总的来说组件封装较频繁使用的属性方法为：`props`/`slot`/`emit`/`ref`

vuex 的使用需要谨慎考虑，具有一定的耦合性，需要进一步探索分析。

对于更优的方式探索值得思考，核心点为职责单一独立、耦合性低，方便维护。

### 业务组件

当前项目已存在的一些业务组件分析：

1. 存在大量的基于基础 UI 组件封装的一些功能组件，属于比较基础类的
2. 其次，存在着基于上述基础组件封装，进而进一步组合封装的业务组件
   - 举例：单个`FilterBtn组件`、`Table组件`、`Pagination组件`，进而组合成整体的一个组件，如：`pro-table`（包含列表、筛选、分页）
   - 举例：使用频率相当高的 `ComSqlTipTree组件`，也是集合了众多子组件的一个组合(涉及到对`Input`的高级封装、`Select`、列表等)

### 小结

基本分析结果思考：

可以参照`pro-component`高级组件的管理模式进行处理。

即，大量基于基础组件封装而成的高级组件，如：`pro-layout`、`pro-table`、`pro-form`等，每个组件可以作为独立的`npm`包作为依赖使用，相互独立、互不影响。

因此，基本确定可以为多包管理的方向（Monorepo）。

## 技术调研

### Monorepo 多包管理

- Monorepo：所有依赖库完全放入一个项目工程
- Multirepo：多个依赖包独立进行 git 管理

综合考虑采用 Monorepo 方案更为合适，以 lerna 框架为核心。

Lerna 是一种工具，针对使用 git 和 npm 管理多软件包代码仓库的工作流程进行优化。

他解决了以下问题：

- 多业务组件、互相依赖、无法复用
- 发包流程复杂、版本管理痛苦

相关开源项目分析：

> 需要考虑的方向是：对于 vue2.x 版本的组件化 lernajs 方案，哪种更为合适
>
> vue2 对于 TS 的考虑、props 参数 API 的文档、pnpm 包管理工具的使用

- [vuetify](https://github.com/vuetifyjs/vuetify)：lernajs+yarn 的方案，标准的 lernajs 用法，vue2.x+ts 写法，组件大量以 JSX 实现，具有很好的参考学习价值（vue2 中对 TS 的合理使用）
- [mint-ui](https://github.com/ElemeFE/mint-ui)：lernajs+yarn 的方案，项目较老（5 年前），主要思路缺乏更新
- [element-plus](https://github.com/element-plus/element-plus)：pnpm 的方案，vue3 的项目，
- [idux](https://github.com/IDuxFE/idux)：pnpm 的方案，vue3 的项目，技术都比较新，学习项目组织方式

### lernaJs + yarn

### pnpm + workspace

新建一个`pnpm-workspace.yaml`，这个文件定义了工作空间的根目录，并能够使您从工作空间中包含 / 排除目录。默认情况下，包含所有子目录。

```js
packages:
  # 所有在 packages/  子目录下的 package
  - 'packages/**'
  # 不包括在 test 文件夹下的 package
  - '!**/test/**'
```

```txt
安装依赖

pnpm add <package_name> --filter <workspace_name> // 安装到指定packages下面的一个包里
pnpm i typescript -w // 安装到根目录 -w(--workspace-root)

运行脚本

pnpm run -C <workspace_name> dev // -C 运行指定包下面的package.json中的脚本


```

共享模块：

当有多个项目集成在`packages`下面时，可以用一个公共的`shared`项目文件夹存放各个项目的公共方法,通过`index.ts`文件导出方法

然后在需要使用的项目中的`packages.json`里面添加 `"shared": "workspace:*"`，再重新执行`pnpm i`，使用：`import { xxx } from 'shared'`;

### 文档管理工具

几个方案：

1. `vuepress`：vuepress 是 Vue 开发
2. `vitepress`：基于 vite 的下一代 vuepress 文档管理工具（本项目 pass）
3. `dumi`：基于 React 开发，具有很完整的支持，开箱即用，react 友好（本项目 pass）
4. 基于 UI 类框架自行开发的文档管理网站（如：antd/elementUI/iviewUI）

说明：

1. vue 官方出品的文档管理工具：`vuepress`、`vitepress`（分为 vue2 的老版本以及新的基于 vite 的 vue3 版本）
2. `vitepress-for-component`：dumi 类 vue 技术栈方向的，基于 vitepress 的知识文档管理框架（[vitepress-for-component](https://github.com/dewfall123/vitepress-for-component)）

#### vuepress 文档框架

1. 对于 vue2 生态进行快速搭建，渲染展示 UI 是可行的

   - vuepress 默认会把`.vuepress/components`文件下的组件注册为全局组件，可在 md 文件中使用
   - 以及在`enhanceApp.js`文件中可以手动按需注册第三方或自定义组件
   - 因此，对于需要展示的 UI 组件在文档中进行渲染展示是没问题的

2. 存在的问题

   - 1. 用于渲染的组件源码、用于文档编写的展示代码，需要独立维护两份
   - 2. 每个组件以及每个组件不同类别分别用于演示渲染的独立组件都需要注册，比较繁琐，建议脚本

## 几点思考

1. 组件化方案选择？
   - 为了便于维护和拓展，考虑`vuepress`、`vitepress`、`varletUI`这种多包管理方案
   - 一方面，可以按照 ElementUI 这种方式直接对基础组件进行管理维护
   - 另一方面，可以按照多包管理的方案对高级组件或其他工具类进行独立维护管理（业务组件、工具类）
   - 最终呈现如：`@ah-ailpha/pro-table`、`@ah-ailpha/com-sqltiptree`
2. 文档站点平台方案？
   - 总的来说，技术栈还是打算以 vue 为主，为了更好的统一整体生态，也有益于维护
   - 多说一句，`dumi`的方案很值得参考学习（react 技术栈）
   - 初步确定在 `vuepress`、`vitepress`两者进行选择
   - 对于市面上大量以 UI 基础组件为核心的项目，基本都是采用自己的 UI 组件进行文档网站的搭建，同时配合脚本完成文档的维护
3. 对于方法类的处理？
   - 具有公共属性的方法，可以结合多包管理进行统一分发、独立维护（如：`@ah/utils`）
4. 部分组件内混用`vuex`对于组件的剥离如何处理？
   - 必须保证不耦合宿主环境的 store，存在风险，以及难以维护性
5. 对于网站主题，自定义组件需要考虑如何优雅继承？
   - 子组件应该受控于容器组件的主题反馈
6. 多包管理方案（Monorepo）？
   - `lernaJs`+`yarn`
   - `pnpm`+`workspace`
7. 如果使用 vitepress 作为网站建设（vitepress 与 vuepress2.x 依赖 vue3.x），会和组件依赖的 vue2.x 版本冲突吗？
   - 不建议使用 vitepress 去搭建 vue2 的文档（[issue274](https://github.com/vuejs/vitepress/issues/274)）
   - 基本定位：vitepress => vue3，vuepress => vue2
8. 对于 API 文档的维护，考虑自动化脚本的可行性？
   - 对于 TypeScript 的 vue3 环境可以很好的做到对文件注释的解析，做到自动化生成 API
9. npm 包私有化部署，公司现有环境
   - 根据代码实际情况，应该主要部署在内外，所以相关项目也应在内外进行
10. 样式引用思考

### npm 发包方式

出于以下几点考虑，目前方案安排如下：

为了方便日后拓展和维护，按照多包管理的模式，以`packages/*`目录下的文件作为一个独立的包发布

- 作为基础组件：`packages/components`=>`@ah-ailpha/components`

- 作为工具库：`packages/utils`=>`@ah-ailpha/utils`

- 作为高级组件：`packages/comSqlTipTree` => `@ah-ailpha/com-sqltiptree`

1. 在 Monorepo 模式下，一切在`packages/*`目录下的文件目录都将作为一个独立的 npm 包进行维护，这样对于后期增加其他功能可以预留一定的拓展性。

2. 普通组件直接在`packages/components`目录下，按照规范创建对应组件目录即可，发包后会作为`@ah-ailpha/components`的内部包提供用户使用

3. 对于高级组件为什么需要单独发包处理呢？

   - 高级组件不同于基础组件，一个组件即为独立的一部分，其打包后的产物也为独立的一份，而不会像 UI 组件一样整体为一个包，这样只需关注其本身即可，没有耦合

   - 高级组件按照当前规范创建，自动适配并发布，在`packages/*`目录下以`com`为前缀创建组件名目录`comEditor`，发包按照 npm 规范自动修正为`com-editor

## 如何参与开发

1. 克隆本仓库

## 资料

- [lernajs](https://www.lernajs.cn/)
- [Lerna 运行流程剖析](https://www.zoo.team/article/lerna-js)
- [pnpm 多包管理项目-爱代码爱编程](https://icode.best/i/54395246194902)
- [pnpm-workspaces](https://pnpm.io/zh/workspaces)
